<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Sorting Description</title>
    <link rel="stylesheet" type="text/css" href="sort.css">

    </head>
    <body>
    <h1>Selection Sort</h1>
    <p>Selection sort is another simple comparison-based sorting algorithm that works by repeatedly finding the minimum (or maximum) element from the unsorted part of the list and putting it at the beginning (or end) of the sorted part of the list. 
        Selection sort has a straightforward, intuitive logic, but it is also relatively inefficient for larger lists. 
    </p>
    <div><h2>How Selection Sort works:</h2>
    <p>
      <ol>
      
       <li><b>
         Finding the Minimum Element:</b> The algorithm scans the entire list to find the minimum element among the unsorted elements. It remembers the index of the minimum element.</li>
       <li><b>
        Swapping with the First Element:</b> Once the minimum element is found, it is swapped with the first element in the unsorted part of the list. This effectively moves it to the sorted part of the list.
       </li>
        <li><b>Expanding the Sorted Portion:</b>
             The sorted portion of the list is expanded by one element, and the unsorted portion is reduced by one element.
        </li>
       <li> <b>Repeating the Process:</b>
        The process is then repeated for the remaining unsorted elements (excluding the last one), with each pass through the list placing the next largest element in its proper position.
        </li>
        <li><b>Repeating the Entire Process:</b>
            Steps 1-3 are repeated for the remaining unsorted elements until the entire list is sorted.
        </li>
        </ol>
    </p>
    </div>
  
    <img src="https://www.boardinfinity.com/blog/content/images/2023/03/Selection-sort.png"
    width="300px" height="200px" >
  
    <h2>Efficiency:</h2>
    <ul>
        <li>Selection Sort has a time complexity of O(n^2), making it inefficient for large lists, similar to Bubble Sort.</li>
        <li>  It is not a stable sort because it may change the relative order of equal elements.</li>
    </ul>
    <h2>Best Case</h2>
    <ul>
    <li> The best-case scenario for Selection Sort is similar to the worst-case scenario. It performs the same number of comparisons and swaps regardless of the initial order of the input list. Therefore, the best case is also the worst case for Selection Sort.</li> 
    <li> <b> Time Complexity:</b> O(n^2), where n is the number of elements in the list.</li>
    </ul>
    <h2>Worst Case</h2>
    <ul>
    <li>The worst-case scenario for Selection Sort also occurs when the input list is sorted in reverse order or in any other order. The algorithm must make the same number of comparisons and swaps, which is the maximum possible for this algorithm.</li> 
    <li> <b>Time Complexity:</b> O(n^2), where n is the number of elements in the list. </li>
    </ul>
    <h2>Use Cases:</h2>
    <ul><li><b>Educational Purposes:</b> Similar to Bubble Sort, Selection Sort is commonly used in educational contexts to teach the fundamentals of sorting algorithms and algorithmic complexity analysis.</li>

    <li><b>Small Datasets:</b> In scenarios where the dataset is small and simplicity is more important than efficiency, Selection Sort can be considered.</li>
    
   <li> <b>Embedded Systems:</b> In resource-constrained environments with limited memory and processing power, Selection Sort's simplicity might make it a suitable choice.</li>
    
    <li><b>Testing and Debugging:</b> Selection Sort can be employed as a basic sorting algorithm to verify the correctness of more complex sorting algorithms or to compare their performance.</li></ul>
    </body>