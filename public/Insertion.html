<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Sorting Description</title>
    <link rel="stylesheet" type="text/css" href="sort.css">

    </head>
    <body>
    <h1>Insertion Sort</h1>
    <p>Insertion sort is a simple sorting algorithm that works similarly to how you sort playing cards in your hand. 
        It iterates through the list, comparing each element to its predecessors and inserting it into its correct position. 
    </p>
    <div><h2>How Insertion sort works:</h2>
    <p>
      <ol>
     
       <li><b>Start with the second element:</b>
        Assume the first element is already sorted, so we begin comparing and inserting from the second element onward.
       <li><b> Compare and Insert:</b>
        For each unsorted element, compare it with the elements in the sorted portion of the array. If the current element is smaller, swap it with the previous element. Continue this process until the current element finds its correct position in the sorted portion.
        
       </li>
        <li><b>Repeat the process:</b>
        After one pass through the list, the largest unsorted element will have "bubbled up" to the end of the list. This means that the largest element is now in its correct sorted position.
        </ol>
    </p>
    </div>
  
    <img src="https://i0.wp.com/www.dotnetforall.com/wp-content/uploads/2019/04/image-8.png?w=778&ssl=1"
    width="300px" height="200px" >
  
    <h2>Efficiency:</h2>
   <ul><li> Insertion Sort is an in-place algorithm, meaning it doesn't require additional memory space.</li>
<li>It's a stable sort, preserving the relative order of equal elements.</li></ul>
     <h2>Best Case</h2>
    <ul>
    <li> If the array is already sorted, there's no need for many swaps, and Insertion Sort performs efficiently in linear time.</li> 
    <li> <b> Time Complexity:</b>O(n), where n is the number of elements in the list. </li>
    </ul>
    <h2>Worst Case</h2>
    <ul>
    <li>In the worst case, when the array is in reverse order, each element might need to be compared and swapped with every preceding element, resulting in a quadratic time complexity.</li> 
    <li> <b>Time Complexity:</b> O(n^2), where n is the number of elements in the list. </li>
    </ul>
    <h2>Use Cases:</h2>
    <p><ul><li>Insertion Sort is efficient for small datasets or nearly sorted datasets.</li>
       <li> Due to its simplicity and minimal memory requirements, it's suitable for situations where the dataset is small, and the overhead of more complex algorithms is not justified.</li></ul>


    </body>