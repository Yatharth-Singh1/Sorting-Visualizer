<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Sorting Description</title>
    <link rel="stylesheet" type="text/css" href="sort.css">

    </head>
    <body>
    <h1>Merge Sort</h1>
    <p>Merge Sort is a divide-and-conquer algorithm that recursively divides an array into halves, sorts each half, 
        and then merges them back together to produce a sorted array.
    </p>
    <div><h2>How Merge sort works:</h2>
    <p>
      <ol>   
       <li><b>Divide:</b>
        Divide the unsorted array into two halves until each sub-array contains only one element (base case of the recursion).
       <li><b> Conquer:</b>
        Recursively sort each sub-array.
       </li>
        <li><b>Merge:</b>
            Merge the sorted sub-arrays back together. Compare elements from each sub-array and merge them into a single sorted array.
        </li>
        </ol>
    </p>
    </div>
    <img src="https://assets-global.website-files.com/5d0dc87aac109e1ffdbe379c/609965777b20e0a46ff1ee4d_TYbxw06o9cbNd314eHaeTRBQzLbkK_r1ZKj-Z24SqjHjL6hDDCz1l6vboE7OeWz-8YnaORdWNrpJtLJeGGmWIaCDIWOt-cf2bAzDBD09rnxlHiFDIDI1E7-9oZ69vFYcdQi_-gfG.png"
    width="300px" height="200px" >
  
    
    <h2>Efficiency:</h2>
   <ul><li> Merge Sort is not an in-place algorithm; it requires additional memory space for the merging process.</li>
    <li>The stability and predictable time complexity of Merge Sort make it suitable for scenarios where a guaranteed upper bound on the time required for any input is crucial.</li></ul>
     <h2>Best Case</h2>
    <ul>
    <li> Merge Sort consistently achieves a time complexity of O(n log n), making it highly efficient for large datasets. The recursive division ensures a logarithmic depth of the recursion tree.</li> 
    <li> <b> Time Complexity:</b>O(n log n), where n is the number of elements in the list. </li>
    </ul>
    <h2>Worst Case</h2>
    <ul>
    <li>Even in the worst-case scenario, the merging step dominates the time complexity, resulting in a stable O(n log n) time complexity.</li> 
    <li> <b>Time Complexity:</b> O(n log n), where n is the number of elements in the list. </li>
    </ul>
    <h2>Use Cases:</h2>
    <p><ul><li>Efficient for sorting large datasets or linked lists due to its consistent time complexity.
       </li>
       <li>  Suitable for scenarios where stability is crucial, as Merge Sort preserves the relative order of equal elements.</li></ul>


    </body>